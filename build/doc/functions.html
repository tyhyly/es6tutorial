<!DOCTYPE html><html><head><meta charset="utf-8" /><title>ES6 - 函数</title><link href="/stylesheets/app.css" rel="stylesheet" type="text/css" /><script src="/javascripts/app.js" type="text/javascript"></script></head><body><div class="sticky"><nav class="top-bar" data-options="sticky_on: large" data-topbar="" role="navigation"><ul class="title-area"><li class="name"><h1><a href="/"> ECMAScript6 Tutorial</a></h1></li><lwi class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></lwi></ul><section class="top-bar-section"><ul class="right"><li id="tool"><a href="/doc/start.html"> 前言</a></li><li id="optimisation"><a href="/doc/optimisation.html"> 优化</a></li><li id="syntax"><a href="/doc/syntax.html"> 语法</a></li><li id="bindings"><a href="/doc/bindings.html"> 绑定</a></li><li id="functions"><a href="/doc/functions.html"> 函数</a></li><li id="built-ins"><a href="/doc/built-ins.html"> 内建</a></li><li id="built-in-extensions"><a href="/doc/built-in-extensions.html"> 内建扩展</a></li><li id="subclassing"><a href="/doc/subclassing.html"> 子类</a></li><li id="misc"><a href="/doc/misc.html"> 混杂</a></li><li id="annex-b"><a href="/doc/annex-b.html"> 附录</a></li><li id="examples"><a href="/examples"> 实例</a></li><li><a href="http://kangax.github.io/compat-table/es6/#ie11tp" target="_blank"> 兼容性</a></li></ul></section></nav></div><div class="wrap"><div class="row"><div class="large-3 columns show-for-large-up"><table class="pos-fixed scroll-nav"></table></div><div class="large-9 columns"><div class="feature"><h4>一、箭头函数</h4><h5 class="subheader">arrow functions</h5><p>ES6 支持使用“箭头”（=>）来定义函数。</p><div class="feature-content"><h5>1.不带参数</h5><h5 class="subheader">0 parameters</h5><pre><code class="javascript">console.log((() =&gt; 5)() === 5); //true
console.log((() => {5;4+2;})());  //undefined</code></pre><p>函数体只有一行代码时，可以省略大括号，指定返回值时可以省略 return；多于一行必须用大括号括起来，且指定返回值时必须带 ‘return’。</p><p>上面代码编译为 ES5 后如下：</p><pre><code class="javascript">console.log((function () {
  return 5;
})() === 5); //true
console.log((function () {
  5;
  4 + 2;
})()); //undefined</code></pre><h5>2.一个参数可以不带括号</h5><h5 class="subheader">1 parameter, no brackets</h5><pre><code class="javascript">var b = x =&gt; x + "foo";
console.log((b("fee fie foe ") === "fee fie foe foo"));</code></pre><p>结果为 true。</p><pre><code class="javascript">var b = x => x + "foo";console.log(x);  //ReferenceError: x is not defined
console.log((b("fee fie foe ") === "fee fie foe foo"));</code></pre><h5>3.多个参数</h5><h5 class="subheader">multiple parameters</h5><pre><code class="javascript">var c = (v, w, x, y, z) =&gt; "" + v + w + x + y + z;
console.log((c(6, 5, 4, 3, 2) === "65432"));</code></pre><p>结果为 true。</p><h5>4.this 绑定</h5><h5 class="subheader">lexical "this" binding</h5><p>函数体内的 this 对象，绑定到定义时的 this 对象。</p><pre><code class="javascript">var d = { x : "bar", y : function() { return z =&gt; this.x + z; }}.y();
var e = { x : "baz", y : d };
console.log(d("ley") === "barley" && e.y("ley") === "barley");</code></pre><p>结果为 true。</p><h5>5.call 和 apply 都不改变 this</h5><h5 class="subheader">"this" unchanged by call or apply</h5><p>由于 this 在箭头函数中被绑定，所以不能用 call()、apply()、bind() 这些方法来改变 this 的指向。</p><pre><code class="javascript">console.log('arrow')
var d = { x : "foo", y : function() { return ()=> {return this.x;} }};
var e = { x : "bar" };
console.log(d.y().call(e));
console.log(d.y().apply(e));

console.log('function')
var d = { x : "foo", y : function() { return function(){return this.x;} }};
var e = { x : "bar" };
console.log(d.y().call(e));
console.log(d.y().apply(e));</code></pre><p>结果为 arrow,foo,foo,function,bar,bar。</p><h5>6.无法绑定 this</h5><h5 class="subheader">can't be bound, can be curried</h5><pre><code class="javascript">var d = { x : "bar", y : function() { return z =&gt; this.x + z; }};
var e = { x : "baz" };
console.log(d.y().bind(e, "ley")() === "barley");</code></pre><p>结果为 true。</p><h5>7.arguments 绑定</h5><h5 class="subheader">lexical "arguments" binding</h5><pre><code class="javascript">function a(){
  console.log(arguments);
}
var b = () => console.log(arguments);
a(1,2); //[1, 2]
b(3,4); //ReferenceError: arguments is not defined</code></pre><p>arguments 对象，在箭头函数体内不存在。</p><pre><code class="javascript">var f = (function() { return z =&gt; arguments[0]; }(5));
console.log(f(6) === 5);</code></pre><p>结果为 true。此时指向的应该是其父函数的 arguments 对象。</p><h5>8.参数和 => 之间不能换行</h5><h5 class="subheader">no line break between params and =&gt;</h5><pre><code class="javascript">console.log((() =&gt; {
 try { Function("x\n =&gt; 2")(); } catch(e) { return true; }
})());</code></pre><p>结果为 true。</p><h5>9.没有 prototype 属性</h5><h5 class="subheader">no "prototype" property</h5><p>箭头函数没有 prototype 属性。</p><pre><code class="javascript">var a = () =&gt; 5;
console.log(!a.hasOwnProperty("prototype"));</code></pre><p>结果为 true。</p><h5>10.super 绑定</h5><h5 class="subheader">lexical "super" binding</h5><pre><code class="javascript">class B {
 qux() {
   return "quux";
 }
}
class C extends B {
 baz() {
 return x =&gt; super.qux();
 }
}
var arrow = new C().baz();
console.log(arrow() === "quux");</code></pre><p>结果为 true。</p><h5>11.new.target 绑定</h5><h5 class="subheader">lexical "new.target" binding</h5><pre><code class="javascript">function C() {
   return x =&gt; new.target;
}
console.log(new C()() === C && C()() === undefined);</code></pre><span class="label radius warning">待测试</span></div></div><div class="feature"><h4>二、类</h4><h5 class="subheader">class</h5><p>ES6 引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类，class 可以看作是一个语法糖，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法。</p><div class="feature-content"><h5>1.class 声明</h5><h5 class="subheader">class statement</h5><pre><code class="javascript">class C {}
console.log(typeof C === "function");</code></pre><p>结果为 true。</p><h5>2.块级作用域</h5><h5 class="subheader">is block-scoped</h5><pre><code class="javascript">class C {}
 var c1 = C;
{
class C {}
  var c2 = C;
}
console.log(C === c1);</code></pre><p>结果为 true。</p><h5>3.class 表达式</h5><h5 class="subheader">class expression</h5><pre><code class="javascript">console.log(typeof class C {} === "function");</code></pre><p>结果为 true。</p><h5>4.匿名 class</h5><h5 class="subheader">anonymous class</h5><pre><code class="javascript">console.log(typeof class {} === "function");</code></pre><p>结果为 true。</p><h5>5.构造函数</h5><h5 class="subheader">constructor</h5><p>constructor 方法是类的默认方法，通过 new 实例化对象时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，该方法会被默认添加，如下：</p><pre><code class="javascript">constructor() {} //默认添加

class C {
 constructor() { this.x = 1; }
}
console.log(C.prototype.constructor === C
  && new C().x === 1);</code></pre><p>结果为 true。</p><h5>6.原型方法</h5><h5 class="subheader">prototype methods</h5><p>除了 constructor 方法外，类的方法都定义在类的 prototype 属性上面。你可以直接把函数定义放到类的定义（大括号内）里面，而且前面不需要加 function 这个保留字。</p><pre><code class="javascript">class C {
 method() { return 2; }
}
console.log(typeof C.prototype.method === "function"
 && new C().method() === 2);</code></pre><p>结果为 true。</p><h5>7.方法名带空格</h5><h5 class="subheader">string-keyed methods</h5><pre><code class="javascript">class C {
 "foo bar"() { return 2; }
}
console.log(typeof C.prototype["foo bar"] === "function"
 && new C()["foo bar"]() === 2);</code></pre><p>结果为 true。</p><h5>8.计算原型方法</h5><h5 class="subheader">computed prototype methods</h5><pre><code class="javascript">var foo = "method";
class C {
 [foo]() { return 2; }
}
console.log(typeof C.prototype.method === "function"
 && new C().method() === 2);</code></pre><p>结果为 true。</p><h5>9.静态方法</h5><h5 class="subheader">static methods</h5><p>在一个方法前，加上 static 关键字，该方法就不会被实例继承，而是直接通过类来调用。</p><pre><code class="javascript">class C {
 static method() { return 3; }
}
console.log(typeof C.method === "function"
 && C.method() === 3);</code></pre><p>结果为 true。</p><h5>10.计算静态方法</h5><h5 class="subheader">computed static methods</h5><pre><code class="javascript">var foo = "method";
class C {
 static [foo]() { return 3; }
}
console.log(typeof C.method === "function"
 && C.method() === 3);</code></pre><p>结果为 true。</p><h5>11.存取器属性</h5><h5 class="subheader">accessor properties</h5><pre><code class="javascript">var baz = false;
class C {
 get foo() { return "foo"; }
 set bar(x) { baz = x; }
}
new C().bar = true;
console.log(new C().foo === "foo" && baz);</code></pre><p>结果为 true。</p><h5>12.计算存取器属性</h5><h5 class="subheader">computed accessor properties</h5><pre><code class="javascript">var garply = "foo", grault = "bar", baz = false;
class C {
  get [garply]() { return "foo"; }
  set [grault](x) { baz = x; }
}
new C().bar = true;
console.log(new C().foo === "foo" && baz);</code></pre><p>结果为 true。</p><h5>13.静态的存取器属性</h5><h5 class="subheader">static accessor properties</h5><pre><code class="javascript">var baz = false;
class C {
 static get foo() { return "foo"; }
 static set bar(x) { baz = x; }
}
C.bar = true;
console.log(C.foo === "foo" && baz);</code></pre><p>结果为 true。</p><h5>14.计算的静态的存取器属性</h5><h5 class="subheader">computed static accessor properties</h5><pre><code class="javascript">var garply = "foo", grault = "bar", baz = false;
class C {
 static get [garply]() { return "foo"; }
 static set [grault](x) { baz = x; }
}
C.bar = true;
console.log(C.foo === "foo" && baz);</code></pre><p>结果为 true。</p><h5>15.类名有词法范围</h5><h5 class="subheader">class name is lexically scoped</h5><pre><code class="javascript">class C {
 method() { return typeof C === "function"; }
}
var M = C.prototype.method;
C = undefined;
console.log(C === undefined && M());</code></pre><p>结果为 true。</p><h5>16.计算类名，暂时性死区</h5><h5 class="subheader">computed names, temporal dead zone</h5><pre><code class="javascript">try {
 var B = class C {
 [C](){}
 }
} catch(e) {
 console.log(true);
}</code></pre><span class="label radius warning">待测试</span><h5>17.方法不能枚举</h5><h5 class="subheader">methods aren't enumerable</h5><pre><code class="javascript">class C {
foo() {}
 static bar() {}
}
console.log(!C.prototype.propertyIsEnumerable("foo") && !C.propertyIsEnumerable("bar"));</code></pre><p>结果为 true。</p><h5>18.使用严格模式</h5><h5 class="subheader">implicit strict mode</h5><pre><code class="javascript">class C {
 static method() { return this === undefined; }
}
console.log((0,C.method)());</code></pre><p>结果为 0,false</p><h5>19.构造函数需要 new</h5><h5 class="subheader">constructor requires new</h5><p>实例化对象时，必须加上 new，否则会报错。</p><pre><code class="javascript">class C {}
try {
 C();
}
catch(e) {
 console.log(true);
}</code></pre><p>结果为 true。</p><h5>20.继承</h5><h5 class="subheader">extends</h5><p>Class 之间可以通过 extends 关键字实现继承，而不需要修改原型链实现继承。</p><pre><code class="javascript">class B {}
class C extends B {}
console.log(new C() instanceof B
 && B.isPrototypeOf(C)
 && B.prototype.isPrototypeOf(C.prototype));</code></pre><p>结果为 true。</p><h5>21.继承表达式</h5><h5 class="subheader">extends expressions</h5><pre><code class="javascript">var B;
class C extends (B = class {}) {}
console.log(new C() instanceof B
 && B.isPrototypeOf(C)
 && B.prototype.isPrototypeOf(C.prototype));</code></pre><p>结果为 true。</p><h5>22.继承 null</h5><h5 class="subheader">extends null</h5><pre><code class="javascript">class C extends null {
 constructor() { return Object.create(null); }
}
var c = new C();
console.log(!(c instanceof Object)
 && Function.prototype.isPrototypeOf(C)
 && Object.getPrototypeOf(C.prototype) === null);</code></pre><p>结果为 true。</p><h5>23.new.target</h5><h5 class="subheader">new.target</h5><pre><code class="javascript">var passed = false;
new function f() {
 passed = new.target === f;
}();

class A {
 constructor() {
   passed &= new.target === B;
 }
}
class B extends A {}
new B();
console.log(passed);</code></pre><span class="label radius warning">待测试</span></div></div><div class="feature"><h4>三、super</h4><h5 class="subheader">super</h5><div class="feature-content"><h5>1.构造函数中的 super 声明</h5><h5 class="subheader">statement in constructors</h5><p>ES6 要求子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。而且，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。</p><pre><code class="javascript">var passed = false;
class B {
  constructor(a) { passed = (a === "barbaz"); }
}
class C extends B {
  constructor(a) { super("bar" + a); }
}
new C("baz");
console.log(passed);</code></pre><p>结果为 true。</p><h5>2.构造函数中的 super 表达式</h5><h5 class="subheader">expression in constructors</h5><pre><code class="javascript">class B {
  constructor(a) { return ["foo" + a]; }
}
class C extends B {
  constructor(a) { return super("bar" + a); }
}
console.log(new C("baz")[0] === "foobarbaz");</code></pre><p>结果为 true。</p><h5>3.方法中用 super 访问属性</h5><h5 class="subheader">in methods, property access</h5><pre><code class="javascript">class B {}
B.prototype.qux = "foo";
B.prototype.corge = "baz";
class C extends B {
  quux(a) { return super.qux + a + super["corge"]; }
}
C.prototype.qux = "garply";
console.log(new C().quux("bar") === "foobarbaz");</code></pre><p>结果为 true。</p><h5>4.方法中用 super 调用方法</h5><h5 class="subheader">in methods, method calls</h5><pre><code class="javascript">class B {
  qux(a) { return "foo" + a; }
}
class C extends B {
  qux(a) { return super.qux("bar" + a); }
}
console.log(new C().qux("baz") === "foobarbaz");</code></pre><p>结果为 true。</p><h5>5.方法调用使用正确的 this 绑定</h5><h5 class="subheader">method calls use correct "this" binding</h5><pre><code class="javascript">class B {
  qux(a) { return this.foo + a; }
}
class C extends B {
  qux(a) { return super.qux("bar" + a); }
}
var obj = new C();
obj.foo = "foo";
console.log(obj.qux("baz") === "foobarbaz");</code></pre><p>结果为 true。</p><h5>6.构造函数调用使用正确的 new.target 绑定</h5><h5 class="subheader">constructor calls use correct "new.target" binding</h5><pre><code class="javascript">var passed;
class B {
  constructor() { passed = (new.target === C); }
}
class C extends B {
  constructor() { super(); }
}
new C();
console.log(passed);</code></pre><span class="label radius warning">待测试</span><h5>7.静态绑定</h5><h5 class="subheader">is statically bound</h5><pre><code class="javascript">class B {
  qux() { return "bar"; }
}
class C extends B {
  qux() { return super.qux() + this.corge; }
}
var obj = {
  qux: C.prototype.qux,
  corge: "ley"
};
console.log(obj.qux() === "barley");</code></pre><p>结果为 true。</p></div></div><div class="feature"><h4>四、Generators</h4><h5 class="subheader">generators</h5><p>generator 是函数内部状态的遍历器。每调用一次，内部状态改变一次。generator 函数有两个特征，一是 function 后面带有一个 <kbd>*</kbd>，二是函数体内有 <kbd>yield</kbd>语句。</p><div class="feature-content"><h5>1.基本功能</h5><h5 class="subheader">basic functionality</h5><pre><code class="javascript">function * generator(){
  yield 5; yield 6;
};
var iterator = generator();
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.next();
passed = passed && item.value === 6 && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>2.generator 函数表达式</h5><h5 class="subheader">generator function expressions</h5><pre><code class="javascript">var generator = function * (){
yield 5; yield 6;
};
var iterator = generator();
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.next();
passed = passed && item.value === 6 && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>3.正确的 this 绑定</h5><h5 class="subheader">correct "this" binding</h5><pre><code class="javascript">function * generator(){
yield this.x; yield this.y;
};
var iterator = { g: generator, x: 5, y: 6 }.g();
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.next();
passed = passed && item.value === 6 && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>4.不能在 new 中使用 this</h5><h5 class="subheader">can't use "this" with new</h5><pre><code class="javascript">function * generator(){
yield this.x; yield this.y;
};
try {
(new generator()).next();
}
catch (e) {
console.log(true);
}</code></pre><span class="label radius warning">待测试</span><h5>5.传递参数</h5><h5 class="subheader">sending</h5><p>yield 语句总是返回 undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 语句的返回值。</p><pre><code class="javascript">var sent;
function * generator(){
sent = [yield 5, yield 6];
};
var iterator = generator();
iterator.next();
iterator.next("foo");
iterator.next("bar");
console.log(sent[0] === "foo" && sent[1] === "bar");      </code></pre><p>结果为 true。</p><h5>6.generator 原型</h5><h5 class="subheader">%GeneratorPrototype%</h5><pre><code class="javascript">function * generatorFn(){}
var ownProto = Object.getPrototypeOf(generatorFn());
var passed = ownProto === generatorFn.prototype;
var sharedProto = Object.getPrototypeOf(ownProto);
passed = passed && sharedProto !== Object.prototype &&
  sharedProto === Object.getPrototypeOf(function*(){}.prototype) &&
  sharedProto.hasOwnProperty('next');
console.log(passed);</code></pre><p>结果为 true。</p><h5>7.generator throw</h5><h5 class="subheader">%GeneratorPrototype%.throw</h5><pre><code class="javascript">var passed = false;
function * generator(){
  try {
  yield 5; yield 6;
} catch(e) {
    passed = (e === "foo");
  }
};
var iterator = generator();
iterator.next();
iterator.throw("foo");
console.log(passed);</code></pre><p>结果为 true。</p><h5>8.generator return</h5><h5 class="subheader">%GeneratorPrototype%.return</h5><pre><code class="javascript">function * generator(){
yield 5; yield 6;
};
var iterator = generator();
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.return("quxquux");
passed = passed && item.value === "quxquux" && item.done === true;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>9.yield 操作符优先级</h5><h5 class="subheader">yield operator precedence</h5><p>yield 操作符的优先级低于 <kbd>?:</kbd> 操作符的优先级。</p><pre><code class="javascript">var passed;
function * generator(){
passed = yield 0 ? true : false;
};
var iterator = generator();
iterator.next();
iterator.next(true);
console.log(passed);</code></pre><p>结果为 true。</p><h5>10.yield *, 数组</h5><h5 class="subheader">yield *, arrays</h5><pre><code class="javascript">var iterator = (function * generator() {
yield * [5, 6];
}());
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.next();
passed = passed && item.value === 6 && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>11.yield *,字符串</h5><h5 class="subheader">yield *, strings</h5><pre><code class="javascript">var iterator = (function * generator() {
  yield * "56";
}());
var item = iterator.next();
var passed = item.value === "5" && item.done === false;
item = iterator.next();
passed = passed && item.value === "6" && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>12.yield *，特殊字符</h5><h5 class="subheader">yield *, astral plane strings</h5><pre><code class="javascript">var iterator = (function * generator() {
yield * "𠮷𠮶";
}());
var item = iterator.next();
var passed = item.value === "𠮷" && item.done === false;
item = iterator.next();
passed = passed && item.value === "𠮶" && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>13.yield *，通用迭代器</h5><h5 class="subheader">yield *, generic iterables</h5><p>首先定义一个通用的迭代器函数：</p><pre><code class="javascript">function __createIterableObject(a, b, c) {
  if (typeof Symbol === "function" && Symbol.iterator) {
    var arr = [a, b, c, ,];
    var iterable = {
      next: function() {
        return { value: arr.shift(), done: arr.length <= 0 };
      },
    };
    iterable[Symbol.iterator] = function(){ return iterable; }
    return iterable;
  }
  else {
    return eval("(function*() { yield a; yield b; yield c; }())");
  }
}</code></pre><p>通过调用这个迭代器函数，生成一个迭代器。</p><pre><code class="javascript">var iterator = (function * generator() {
  yield * __createIterableObject(5, 6, 7);
}());
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.next();
passed = passed && item.value === 6 && item.done === false;
item = iterator.next();
passed = passed && item.value === 7 && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>14.yield *，迭代器实例</h5><h5 class="subheader">yield *, instances of iterables</h5><pre><code class="javascript">var iterator = (function * generator() {
  yield * Object.create(__createIterableObject(5, 6, 7));
}());
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.next();
passed = passed && item.value === 6 && item.done === false;
item = iterator.next();
passed = passed && item.value === 7 && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>15.yield *，迭代器关闭</h5><h5 class="subheader">yield *, iterator closing</h5><pre><code class="javascript">var closed = '';
var iter = __createIterableObject(1, 2, 3);
iter['return'] = function(){
  closed += 'a';
  return {done: true};
}
var gen = (function* generator(){
  try {
    yield *iter;
  } finally {
    closed += 'b';
  }
})();
gen.next();
gen['return']();
console.log(closed === 'ab');</code></pre><span class="label radius warning">待测试</span><h5>16.yield *，迭代器通过 throw 关闭</h5><h5 class="subheader">yield *, iterator closing via throw()</h5><pre><code class="javascript">var closed = false;
var iter = __createIterableObject(1, 2, 3);
iter['throw'] = undefined;
iter['return'] = function(){
  closed = true;
  return {done: true};
}
var gen = (function*(){
  try {
    yield *iter;
  } catch(e){}
})();
gen.next();
gen['throw']();
console.log(closed);</code></pre><span class="label radius warning">待测试</span><h5>17.简写 generator 方法</h5><h5 class="subheader">shorthand generator methods</h5><pre><code class="javascript">var o = {
  * generator() {
    yield 5; yield 6;
  },
};
var iterator = o.generator();
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.next();
passed = passed && item.value === 6 && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>18.带空格字符串的简写 generator 方法</h5><h5 class="subheader">string-keyed shorthand generator methods</h5><pre><code class="javascript">var o = {
  * "foo bar"() {
    yield 5; yield 6;
  },
};
var iterator = o["foo bar"]();
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.next();
passed = passed && item.value === 6 && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>19.计算简写 generator</h5><h5 class="subheader">computed shorthand generators</h5><pre><code class="javascript">var garply = "generator";
var o = {
  * [garply] () {
    yield 5; yield 6;
  },
};
var iterator = o.generator();
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.next();
passed = passed && item.value === 6 && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>20.简写 generator 方法，类</h5><h5 class="subheader">shorthand generator methods, classes</h5><pre><code class="javascript">class C {
  * generator() {
    yield 5; yield 6;
  }
};
var iterator = new C().generator();
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.next();
passed = passed && item.value === 6 && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p><h5>21.计算简写 generator 方法，类</h5><h5 class="subheader">computed shorthand generators, classes</h5><pre><code class="javascript">var garply = "generator";
class C {
  * [garply] () {
    yield 5; yield 6;
  }
}
var iterator = new C().generator();
var item = iterator.next();
var passed = item.value === 5 && item.done === false;
item = iterator.next();
passed = passed && item.value === 6 && item.done === false;
item = iterator.next();
passed = passed && item.value === undefined && item.done === true;
console.log(passed);</code></pre><p>结果为 true。</p></div></div></div></div><script type="text/javascript">$(document).ready(function() {
  var animate = false;
  var active_nav =  function(){
    $('.feature h4').each(function(i, el){
      if (animate) return;
      if (Math.abs($(window).scrollTop() - $(el).offset().top) < 60) {
        $('.scroll-nav td').removeClass('active');
        $($('.scroll-nav td')[i]).addClass('active');
      }
    });
  };
  active_nav();
  $('.scroll-nav').width($('.scroll-nav').parent('.large-3').width()-20);
  $('.feature h4').each(function(i, el){
    $(this).attr('data-text', $(el).text().split('、')[1]);
    if(i == 0){
      $('.scroll-nav').append('<tr><td class="active">' + $(el).text().split('、')[1] + '</td></tr>');
    } else {
      $('.scroll-nav').append('<tr><td>' + $(el).text().split('、')[1] + '</td></tr>');
    }
  });
  $('.scroll-nav td').on('click', function(e){
    e.preventDefault();
    if($(this).find('a').length > 0){
      var target = $( $(this).find('a').attr('href') );
    } else {
      var target = $('.feature').find('[data-text="' + $(this).text() + '"]');
    }
    $('.scroll-nav td').removeClass('active');
    $(this).addClass('active');
    animate = true;
    $('html, body').animate({
      scrollTop: target.offset().top - 48
    }, 1000, 
    function(){
      animate = false;
    });
  });
  $(document).scroll(function(){
    active_nav();
  });
});</script><script type="text/javascript">$("#functions").addClass('active');</script></div><div class="footer wrap"><div class="row"><div class="large-8 large-centered small-10 small-centered"><p>项目托管在<a href="https://github.com/wendycan/es6tutorial" target="_blank"><i class="fa fa-ok"></i>GitHub</a></p><p>作者<a href="https://github.com/wendycan" target="_blank">wendy</a></p><p>友情链接<a href="http://larklearning.com" target="_blank">wendy的小站</a><a href="http://yuetai.larklearning.com" target="_blank">阅台</a></p></div></div></div><script type="text/javascript">$(document).foundation();
hljs.initHighlightingOnLoad();</script></body></html>