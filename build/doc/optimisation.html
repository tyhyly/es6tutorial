<!DOCTYPE html><html><head><meta charset="utf-8" /><title>ES6 - 优化</title><link href="/stylesheets/app.css" rel="stylesheet" type="text/css" /><script src="/javascripts/app.js" type="text/javascript"></script></head><body><div class="sticky"><nav class="top-bar" data-options="sticky_on: large" data-topbar="" role="navigation"><ul class="title-area"><li class="name"><h1><a href="/"> ECMAScript6 Tutorial</a></h1></li><lwi class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></lwi></ul><section class="top-bar-section"><ul class="right"><li id="tool"><a href="/doc/start.html"> 前言</a></li><li id="optimisation"><a href="/doc/optimisation.html"> 优化</a></li><li id="syntax"><a href="/doc/syntax.html"> 语法</a></li><li id="bindings"><a href="/doc/bindings.html"> 绑定</a></li><li id="functions"><a href="/doc/functions.html"> 函数</a></li><li id="built-ins"><a href="/doc/built-ins.html"> 内建</a></li><li id="built-in-extensions"><a href="/doc/built-in-extensions.html"> 内建扩展</a></li><li id="subclassing"><a href="/doc/subclassing.html"> 子类</a></li><li id="misc"><a href="/doc/misc.html"> 混杂</a></li><li id="annex-b"><a href="/doc/annex-b.html"> 附录</a></li><li id="examples"><a href="/examples"> 实例</a></li><li><a href="http://kangax.github.io/compat-table/es6/#ie11tp" target="_blank"> 兼容性</a></li></ul></section></nav></div><div class="wrap"><div class="row feature"><div class="large-12 columns"><h4>适当的尾部调用</h4><h5 class="subheader">Proper tail calls (Tail call optimisation)</h5><p>函数的调用会在内存形成一个调用记录，又称<kbd>调用帧（call frame）</kbd>，保存调用位置和内部变量等信息。
如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，
B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，
就形成一个“调用栈”（call stack）。</p><img src="/images/function_call.png" /><img src="/images/function_call_stack.png" /><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，
只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p><pre><code class="javascript">function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();
function f() {
  return g(3);
}
f();
g(3);</code></pre><p>下面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n)。</p><pre><code class="javascript">function factorial(n) {
if (n === 1) return 1;
  return n * factorial(n - 1);
}
factorial(5) // 120</code></pre><p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p><pre><code class="javascript">function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}
factorial(5, 1) // 120</code></pre><p>尾调用优化和非尾调用优化的栈区别，如下图所示：</p><img src="/images/tail_stack.png" /><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。德罗斯特效应（Droste effect），
是一种递归的模式，指一张图片部分与整张图片相同，一张有德罗斯特效应的图片，在其中会有一小部分是和整张图片类似。
而这小部分的图片中，又会有一小部分是和整张图片类似，以此类推，……。德罗斯特效应的名称是由于荷兰著名厂牌德罗斯特（Droste）
可可粉的包装盒，包装盒上的图案是一位护士拿着一个有杯子及纸盒的托盘，而杯子及纸盒上的图案和整张图片相同[1]。</p><img src="/images/droste_effect.jpg" /></div><div class="large-12 columns"><h5>1.直接递归</h5><h5 class="subheader">Direct recursion</h5><pre><code class="javascript">function f(n){
  if (n &lt;= 0) {
  return "foo";
  }
return f(n - 1);
}
console.log(f(1e6) === "foo");</code></pre></div><div class="large-12 columns"><h5>2.互递归</h5><h5 class="subheader">Mutual recursion</h5><pre><code>function f(n){
  if (n &lt;= 0) {
    return  "foo";
  }
  return g(n - 1);
}
function g(n){
  if (n &lt;= 0) {
    return  "bar";
  }
  return f(n - 1);
}
return f(1e6) === "foo" && f(1e6+1) === "bar";</code></pre><p>使用互递归判断一个数的奇偶性。</p><pre><code>function _even(n){
  if(n == 0){
    return 'even'
  } else {
    _odd(n-1);
  }
}
function _odd(n){
  if(n == 0){
    return 'odd'
  } else {
    _even(n-1)
  }
}
function judge(n){
  var r = is_even(n);
  console.log(r);
}
judge(7);</code></pre></div></div><div class="row"><div class="large-12 columns"><div class="reference"><h6>参考</h6><ul><li><a href="http://zh.wikipedia.org/wiki/%E5%BE%B7%E7%BD%97%E6%96%AF%E7%89%B9%E6%95%88%E5%BA%94" target="black">德罗斯特效应</a></li></ul></div></div></div><script type="text/javascript">$("#optimisation").addClass('active');</script></div><div class="footer wrap"><div class="row"><div class="large-8 large-centered small-10 small-centered"><p>项目托管在<a href="https://github.com/wendycan/es6tutorial" target="_blank"><i class="fa fa-ok"></i>GitHub</a></p><p>作者<a href="https://github.com/wendycan" target="_blank">wendy</a></p><p>友情链接<a href="http://wendy.larklearning.com" target="_blank">wendy的小站</a><a href="http://yuetai.larklearning.com" target="_blank">阅台</a></p></div></div></div><script type="text/javascript">$(document).foundation();
hljs.initHighlightingOnLoad();</script></body></html>